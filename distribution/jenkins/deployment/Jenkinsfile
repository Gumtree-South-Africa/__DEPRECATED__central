#!/usr/bin/env groovy

library "commonFunctions@${PROVIDED_PIPELINE_BRANCH}"

def checkInputParameters(providedVersion, providedEnv, providedDc, providedTenant) {
    if (providedDc == "-") {
        error("Please provide a DC")
    }
    if (providedTenant == "-") {
        error("Please provide a tenant")
    }
    if (providedVersion != '' && !(providedVersion =~ /^\d{4}\.\d{2}\..+/)) {
        error("Provided version does not have the form 'YYYY.mm.xxx', or empty. Leave empty to deploy the version on LP.")
    }
    if (providedEnv == 'lp' && providedVersion == '') {
        error("You did not provide a version to deploy to lp. Don't know what to do.")
    }
    if (providedDc != 'ams1' && providedEnv == 'lp') {
        error("The lp environment is only available in the ams1 dc.")
    }
    if (!commonFunctions.allTenants().contains(providedTenant) && providedEnv != 'lp') {
        error("You are trying to deploy to all tenants on production. This is not allowed.")
    }
}

void deploymentFailed(final String tenant, final String version, final String dc,
                      final String environmentShort, final Exception ex) {
    echo "--->>> Exception: $ex"
    exMessage = ex.getMessage()
    String currentVersion = commonFunctions.getCurrentlyDeployedVersion(tenant, dc, environmentShort)
    String slackMessage = "Deploying Comaas `$tenant` `$version` to `$environmentShort` failed with `$exMessage`, `$currentVersion` remains"
    String graphitePayload = commonFunctions.createGraphitePayload('failed', commonFunctions.getAlias(tenant), "tried $version, current $currentVersion remains")

    sendGraphiteMetric(dc, environmentShort, graphitePayload)
    sendToSlack('#FF0000', tenant, slackMessage, environmentShort)

    error("Deploying Comaas version $version to $environmentShort failed with $exMessage")
}

void sendGraphiteMetric(String dc, String environmentShort, String jsonPayload) {
    sh "curl -s -X POST 'https://graphite.comaas-${environmentShort}.${dc}.cloud/events/' -d '$jsonPayload'"
}

void sendToSlack(final String colour, final String channel, final String message, final String environmentShort) {
    final String c = environmentShort == 'lp' ? 'jenkins' : channel
    commonFunctions.sendToSlack(colour, c, message)
    if (environmentShort == 'prod') {
        commonFunctions.sendToSlackProdChannel(colour, message)
    }
}

String activeDcSlackString(final String tenantLong, final String dc, final String environmentShort) {
    if (environmentShort != "prod") {
        return ""
    }
    return commonFunctions.getActiveDC(tenantLong, environmentShort) == dc ? "*active DC*" : "_passive DC_"
}

void notifyAboutPendingUpgrade(final String tenant, final String version, final String dc,
                               final String environmentShort) {
    final String currentVersion = commonFunctions.getCurrentlyDeployedVersion(tenant, dc, environmentShort)
    final String dcState = activeDcSlackString(tenant, dc, environmentShort)

    String slackMessage = "Upgrading Comaas for `$tenant` from version `$currentVersion` to `$version` on `$environmentShort` " +
            "in `$dc` $dcState (<https://github.corp.ebay.com/ecg-comaas/central/compare/$currentVersion...$version|Diff>) (<$BUILD_URL|Build>)"

    String graphitePayload = commonFunctions.createGraphitePayload('started', commonFunctions.getAlias(tenant), "from $currentVersion to $version")

    sendGraphiteMetric(dc, environmentShort, graphitePayload)
    sendToSlack('#FFFF00', tenant, slackMessage, environmentShort)
}

String downloadVersionFromSwift(final String tenant, final String version) {
    withCredentials([[$class          : 'UsernamePasswordMultiBinding', credentialsId: 'swift',
                      usernameVariable: 'SWIFT_USER', passwordVariable: 'SWIFT_PASS']]) {

        final String userId = commonFunctions.getUID()
        final String artifact = "${tenant}/builds/comaas-${tenant}_${version}.tar.gz"

        sh """
                docker run \\
                --rm \\
                --network host \\
                -u $userId \\
                -v \$PWD:/objects \\
                -e OS_AUTH_URL=https://keystone.dus1.cloud.ecg.so/v2.0 \\
                -e OS_TENANT_NAME="comaas-qa" \\
                -e OS_USERNAME="$SWIFT_USER" \\
                -e OS_PASSWORD="$SWIFT_PASS" \\
                -e OS_PROJECT_NAME="comaas-control-prod" \\
                -e OS_REGION_NAME="dus1" \\
                registry.ecg.so/mp-so/python-swiftclient:latest \\
                swift download --output-dir /objects --skip-identical --prefix $artifact comaas
            """

        final String moveStatus = sh(
                script: "mv -v $artifact .",
                returnStatus: true
        )
        if (moveStatus != "0") {
            error("Could not find artifact $artifact in Swift")
        }
    }

    return "comaas-${tenant}_${version}.tar.gz"
}

void downloadFileFromGithub(final String version, final String tenant, final String environmentShort) {
    final String destination = "props.properties"

    withCredentials([string(credentialsId: 'GITHUBBOT-COMAAS-PAT', variable: 'TOKEN')]) {
        String filePath = "ecg-comaas/central/$version/distribution/conf/$tenant/${environmentShort}.properties"
        String status = sh(
                script: "curl --fail -o $destination -sLH 'Authorization: token $TOKEN' https://raw.github.corp.ebay.com/$filePath",
                returnStatus: true
        )
        if (status != "0") {
            filePath = "ecg-comaas/central/$version/distribution/conf/$tenant/import_into_consul/${environmentShort}.properties"
            status = sh(
                    script: "curl --fail -o $destination -sLH 'Authorization: token $TOKEN' https://raw.github.corp.ebay.com/$filePath",
                    returnStatus: true
            )
            if (status != "0") {
                error("Could not download $filePath from Github (also tried without 'import_into_consul')")
            }
        }
    }
}

void loadPropsIntoConsul(final String tenant, final String version, final String environmentShort) {
    downloadFileFromGithub(version, tenant, environmentShort)

    final String status = sh(
            script: "properties-to-consul -file props.properties",
            returnStatus: true
    )
    if (status != "0") {
        error("Could not load properties into Consul, tenant $tenant, version $version, environment $environmentShort")
    }
}

void deployToEnv(final String tenant, final String artifact, final String environment, final String version, final String dc, final Integer nrOfInstances) {
    ansiColor('xterm') {
        sh "PYTHONWARNINGS='ignore' deploy.py --config /etc/comaas/comaas-${tenant}.yaml --logdir ~ --component $artifact"
    }

    final String tenantShort = commonFunctions.getAlias(tenant)

    // There are 4 availability zones (called DC in Nomad), and we want to be able to both spread more or less evenly
    // over zones, and have the allocation space to reschedule enough instances when a zone goes down. This is a best
    // effort effort:
    final Integer nrOfInstancesPerZone = nrOfInstances.intdiv(4) + 1

    // Is this really necessary? Can we pass the files to the builder instead?
    checkout scm

    withCredentials([[$class          : 'UsernamePasswordMultiBinding', credentialsId: 'docker-registry',
                      usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS']]) {
        nomadFile = "core-api.nomad"
        if (environment == "lp" || tenant == "gtuk") {
            nomadFile = "core-api_ACTIVE.nomad"
        }

        sh "levant render " +
                "-var-file=distribution/jenkins/deployment/environments/${environment}.tf " +
                "-var='version=${version}' " +
                "-var='docker_password=${DOCKER_PASS}' " +
                "-var='tenant=${tenant}' " +
                "-var='tenant_short=${tenantShort}' " +
                "-var='environment=${environment}' " +
                "-var='region=${dc}' " +
                "-var='api_count=${nrOfInstances}' " +
                "-var='api_count_per_zone=${nrOfInstancesPerZone}' " +
                "distribution/jenkins/deployment/${nomadFile}"
        sh "levant deploy " +
                "-log-level=debug " +
                "-force-count=true " +
                "-address='http://http.nomad.service.consul:4646' " +
                "-var-file=distribution/jenkins/deployment/environments/${environment}.tf " +
                "-var='version=${version}' " +
                "-var='docker_password=${DOCKER_PASS}' " +
                "-var='tenant=${tenant}' " +
                "-var='tenant_short=${tenantShort}' " +
                "-var='environment=${environment}' " +
                "-var='region=${dc}' " +
                "-var='api_count=${nrOfInstances}' " +
                "-var='api_count_per_zone=${nrOfInstancesPerZone}' " +
                "distribution/jenkins/deployment/${nomadFile}"
    }
}

Closure wrapWithStepDefinition(
        final String tenant, final String version, final String environmentShort,
        final String dc, final String stageName, final boolean force, final Integer nrOfInstances) {
    return {
        stage(stageName) {
            node("$environmentShort && $dc") {
                boolean skip = false

                if (force) {
                    echo "Force deployment, not checking existing version. Note that deploy.py or levant may still not upgrade for same version."
                } else {
                    try {
                        String currentlyDeployedVersion = commonFunctions.getCurrentlyDeployedVersion(tenant, dc, environmentShort)
                        echo "currentlyDeployedVersion == newVersion : $currentlyDeployedVersion == $version"
                        if (currentlyDeployedVersion == version) {
                            echo "Current Comaas $tenant version $currentlyDeployedVersion is up to date, nothing to update (desired version: $version)"
                            currentBuild.result = 'SUCCESS'
                            skip = true
                            return
                        }
                    } catch (ex) {
                        deploymentFailed(tenant, version, dc, environmentShort, ex)
                    } finally {
                        if (skip) {
                            cleanWs notFailBuild: true
                        }
                    }
                }

                if (!skip) {
                    try {
                        echo "About to deploy Comaas version $version to $environmentShort in $dc for $tenant"
                        notifyAboutPendingUpgrade(tenant, version, dc, environmentShort)

                        if (!commonFunctions.isVersionPresentInSwift(tenant, version)) {
                            error("Version $version for tenant $tenant was not found in Swift")
                        }

                        // To be used in a later commit, when we'll implement Docker image deployment
                        // loginToDocker()
                        // check if available in docker registry
                        // https://docs.docker.com/registry/spec/auth/token/#requesting-a-token
                        // https://docs.docker.com/registry/spec/api/

                        final String artifact = downloadVersionFromSwift(tenant, version)
                        loadPropsIntoConsul(tenant, version, environmentShort)
                        deployToEnv(tenant, artifact, environmentShort, version, dc, nrOfInstances)

                        final String graphitePayload = commonFunctions.createGraphitePayload('succeeded', commonFunctions.getAlias(tenant), "$version deployed")
                        sendGraphiteMetric(dc, environmentShort, graphitePayload)

                        final String activeDcSlack = activeDcSlackString(tenant, dc, environmentShort)
                        final String slackMessage = "Comaas version `$version` for `$tenant` successfully deployed to " +
                                "`$environmentShort` in `$dc` ${activeDcSlack} with ${nrOfInstances} API nodes"
                        sendToSlack('#00FF00', tenant, slackMessage, environmentShort)
                    } catch (ex) {
                        deploymentFailed(tenant, version, dc, environmentShort, ex)
                    } finally {
                        cleanWs notFailBuild: true
                    }
                }
                if (env."SKIP_$tenant" != 'true') {
                    try {
                        echo "Running smoke tests for $PROVIDED_TENANT against $PROVIDED_DC $PROVIDED_ENV"
                        build job: 'smoke-tests', parameters: [
                                string(name: 'PROVIDED_TENANT', value: "$PROVIDED_TENANT"),
                                string(name: 'PROVIDED_ENV', value: "$PROVIDED_ENV"),
                                string(name: 'PROVIDED_DC', value: "$PROVIDED_DC")
                        ], wait: false
                    } finally {
                        cleanWs notFailBuild: true
                    }
                }
            }
        }
    }
}

static boolean useLpVersionForProd(final String versionToDeploy, final String environmentShort) {
    return versionToDeploy == '' && environmentShort == 'prod'
}

node(PROVIDED_ENV) {
    checkout scm

    checkInputParameters(PROVIDED_VERSION, PROVIDED_ENV, PROVIDED_DC, PROVIDED_TENANT)

    configFile = readYaml file: "distribution/jenkins/deployment/configuration.yaml"

    String[] tenants

    if (PROVIDED_ENV == 'lp') {
        configFile = readYaml file: "distribution/jenkins/deployment/lp/configuration.yaml"

        if (PROVIDED_TENANT == 'all-enabled') {
            tenants = commonFunctions.activeTenants(configFile.tenants.disabled as List)
        } else {
            tenants = [PROVIDED_TENANT]
        }
    } else {
        tenants = [PROVIDED_TENANT]
    }

    final String environmentShort = PROVIDED_ENV
    String versionToDeploy = PROVIDED_VERSION.trim()
    String dc = PROVIDED_DC
    final boolean force = PROVIDED_FORCE == 'true'

    if (useLpVersionForProd(versionToDeploy, environmentShort)) {
        // If the version is empty, deploy the version that's live on lp to prod
        versionToDeploy = commonFunctions.getCurrentlyDeployedVersion(tenants[0], 'ams1', 'lp')
    }

    if (environmentShort == "prod") {
        // This implies only a single tenant is selected, see checkInputParameters(), but let's make sure
        if (tenants.length != 1) {
            error("You cannot use active/passive dc when deploying to multiple tenants")
        }

        switch (dc) {
            case "active":
                dc = commonFunctions.getActiveDC(tenants[0], "prod")
                break
            case "passive":
                dc = commonFunctions.getPassiveDcProd(tenants[0])
                break
        }
    }

    currentBuild.description = "$PROVIDED_TENANT/$dc/$versionToDeploy"

    buildSteps = ["failFast": false]
    buildSteps += tenants.collectEntries { tenant ->
        String n = "$tenant-deployment"
        Integer nrOfInstances = environmentShort == 'lp' ? 3 : configFile.instances[tenant] as Integer
        return [(n): wrapWithStepDefinition(tenant, versionToDeploy, environmentShort, dc, "Deploy $tenant", force, nrOfInstances)]
    }
    parallel buildSteps

    if (currentBuild.result == 'FAILURE') {
        currentBuild.result = 'UNSTABLE'
    }
}
