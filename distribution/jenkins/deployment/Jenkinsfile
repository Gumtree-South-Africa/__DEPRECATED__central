#!/usr/bin/env groovy

library "commonFunctions@${PROVIDED_PIPELINE_BRANCH}"

def checkInputParameters(providedVersion, providedEnv, providedDc, providedTenant) {
    if (providedDc == "-") {
        error("Please provide a DC")
    }
    if (providedTenant == "-") {
        error("Please provide a tenant")
    }
    if (providedVersion != '' && !(providedVersion =~ /^\d{4}\.\d{2}\..+/)) {
        error("Provided version does not have the form 'YYYY.mm.xxx', or empty. Leave empty to deploy the version on LP.")
    }
    if (providedEnv == 'lp' && providedVersion == '') {
        error("You did not provide a version to deploy to lp. Don't know what to do.")
    }
    if (providedDc != 'ams1' && providedEnv == 'lp') {
        error("The lp environment is only available in the ams1 dc.")
    }
    if (!commonFunctions.allTenants().contains(providedTenant) && providedEnv != 'lp') {
        error("You are trying to deploy to all tenants on production. This is not allowed.")
    }
}

void deploymentFailed(final String tenant, final String version, final String dc,
                      final String environmentShort, final Exception ex) {
    echo "--->>> Exception: $ex"
    exMessage = ex.getMessage()
    String currentVersion = commonFunctions.getCurrentlyDeployedVersion(tenant, dc, environmentShort)
    String slackMessage = "Deploying Comaas `$tenant` `$version` to `$environmentShort` failed with `$exMessage`, `$currentVersion` remains"
    String graphitePayload = commonFunctions.createGraphitePayload('failed', commonFunctions.getAlias(tenant), "tried $version, current $currentVersion remains")

    sendGraphiteMetric(dc, environmentShort, graphitePayload)
    sendToSlack('#FF0000', tenant, slackMessage, environmentShort)

    error("Deploying Comaas version $version to $environmentShort failed with $exMessage")
}

void sendGraphiteMetric(String dc, String environmentShort, String jsonPayload) {
    sh "curl -s -X POST 'https://graphite.comaas-${environmentShort}.${dc}.cloud/events/' -d '$jsonPayload'"
}

void sendToSlack(final String colour, final String channel, final String message, final String environmentShort) {
    final String c = environmentShort == 'lp' ? 'jenkins' : channel
    commonFunctions.sendToSlack(colour, c, message)
    if (environmentShort == 'prod') {
        commonFunctions.sendToSlackProdChannel(colour, message)
    }
}

String activeDcSlackString(final String tenantLong, final String dc, final String environmentShort) {
    if (environmentShort != "prod") {
        return ""
    }
    return commonFunctions.getActiveDC(tenantLong, environmentShort) == dc ? "*active DC*" : "_passive DC_"
}

void notifyAboutPendingUpgrade(final String tenant, final String version, final String dc,
                               final String environmentShort) {
    final String currentVersion = commonFunctions.getCurrentlyDeployedVersion(tenant, dc, environmentShort)
    final String dcState = activeDcSlackString(tenant, dc, environmentShort)

    String slackMessage = "Upgrading Comaas for `$tenant` from version `$currentVersion` to `$version` on `$environmentShort` " +
            "in `$dc` $dcState (<https://github.corp.ebay.com/ecg-comaas/central/compare/$currentVersion...$version|Diff>) (<$BUILD_URL|Build>)"

    String graphitePayload = commonFunctions.createGraphitePayload('started', commonFunctions.getAlias(tenant), "from $currentVersion to $version")

    sendGraphiteMetric(dc, environmentShort, graphitePayload)
    sendToSlack('#FFFF00', tenant, slackMessage, environmentShort)
}

String downloadVersionFromSwift(final String tenant, final String version) {
    withCredentials([[$class          : 'UsernamePasswordMultiBinding', credentialsId: 'swift',
                      usernameVariable: 'SWIFT_USER', passwordVariable: 'SWIFT_PASS']]) {

        final String userId = commonFunctions.getUID()
        final String artifact = "${tenant}/builds/comaas-${tenant}_${version}.tar.gz"

        sh """
                docker run \\
                --rm \\
                --network host \\
                -u $userId \\
                -v \$PWD:/objects \\
                -e OS_AUTH_URL=https://keystone.dus1.cloud.ecg.so/v2.0 \\
                -e OS_TENANT_NAME="comaas-qa" \\
                -e OS_USERNAME="$SWIFT_USER" \\
                -e OS_PASSWORD="$SWIFT_PASS" \\
                -e OS_PROJECT_NAME="comaas-control-prod" \\
                -e OS_REGION_NAME="dus1" \\
                ebayclassifiedsgroup/python-swiftclient:3.5.0 \\
                swift download --output-dir /objects --skip-identical --prefix $artifact comaas
            """

        final String moveStatus = sh(
                script: "mv -v $artifact .",
                returnStatus: true
        )
        if (moveStatus != "0") {
            error("Could not find artifact $artifact in Swift")
        }
    }

    return "comaas-${tenant}_${version}.tar.gz"
}

void downloadFileFromGithub(final String version, final String tenant, final String environmentShort) {
    final String destination = "props.properties"

    withCredentials([string(credentialsId: 'GITHUBBOT-COMAAS-PAT', variable: 'TOKEN')]) {
        String filePath = "ecg-comaas/central/$version/distribution/conf/$tenant/${environmentShort}.properties"
        String status = sh(
                script: "curl --fail -o $destination -sLH 'Authorization: token $TOKEN' https://raw.github.corp.ebay.com/$filePath",
                returnStatus: true
        )
        if (status != "0") {
            filePath = "ecg-comaas/central/$version/distribution/conf/$tenant/import_into_consul/${environmentShort}.properties"
            status = sh(
                    script: "curl --fail -o $destination -sLH 'Authorization: token $TOKEN' https://raw.github.corp.ebay.com/$filePath",
                    returnStatus: true
            )
            if (status != "0") {
                error("Could not download $filePath from Github (also tried without 'import_into_consul')")
            }
        }
    }
}

void loadPropsIntoConsul(final String tenant, final String version, final String environmentShort) {
    downloadFileFromGithub(version, tenant, environmentShort)

    final String status = sh(
            script: "properties-to-consul -file props.properties",
            returnStatus: true
    )
    if (status != "0") {
        error("Could not load properties into Consul, tenant $tenant, version $version, environment $environmentShort")
    }
}

void deployToEnv(final String tenant, final String artifact, final String environment, final String version, final String dc, final Integer nrOfInstances, final boolean live) {
    ansiColor('xterm') {
        sh "PYTHONWARNINGS='ignore' deploy.py --config /etc/comaas/comaas-${tenant}.yaml --logdir ~ --component $artifact"
    }

    final String tenantShort = commonFunctions.getAlias(tenant)

    // There are 4 availability zones (called DC in Nomad), and we want to be able to both spread more or less evenly
    // over zones, and have the allocation space to reschedule enough instances when a zone goes down. This is a best
    // effort effort:
    final Integer nrOfInstancesPerZone = nrOfInstances.intdiv(4) + 1

    // Is this really necessary? Can we pass the files to the builder instead?
    checkout scm

    withCredentials([[$class          : 'UsernamePasswordMultiBinding', credentialsId: 'docker-registry',
                      usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS']]) {

        urlprefixes = ""
        if (live || environment == "lp") {
            urlprefixes = ",urlprefix-${tenantShort}.${environment}.comaas.cloud/,urlprefix-${dc}.${tenantShort}.${environment}.comaas.cloud/"

            if (tenantShort == 'au') {
                if (environment == 'lp') {
                    urlprefixes += ",urlprefix-au-comaas.dro.ops.qa.au.ecg.so:8006/"
                }
                if (environment == 'prod') {
                    urlprefixes += ",urlprefix-au-rts2-api:8080/,urlprefix-au-rts2-api.intern.gumtree.com.au:8080/"
                }
            }
        }

        final String deployJenkinsJob = env.BUILD_NUMBER
        final String vars = "-var-file=distribution/jenkins/deployment/environments/${environment}.tf " +
                "-var='version=${version}' " +
                "-var='urlprefixes=${urlprefixes}' " +
                "-var='docker_password=${DOCKER_PASS}' " +
                "-var='tenant=${tenant}' " +
                "-var='tenant_short=${tenantShort}' " +
                "-var='environment=${environment}' " +
                "-var='region=${dc}' " +
                "-var='api_count=${nrOfInstances}' " +
                "-var='api_count_per_zone=${nrOfInstancesPerZone}' " +
                "-var='deploy_jenkins_job_nr=${deployJenkinsJob}' "

        sh "levant render ${vars} distribution/jenkins/deployment/core-api.nomad"
        sh "levant deploy -log-level=debug -address='http://http.nomad.service.consul:4646' -force-count=true ${vars} " +
                "distribution/jenkins/deployment/core-api.nomad"
    }
}

static boolean useLpVersionForProd(final String versionToDeploy, final String environmentShort) {
    return versionToDeploy == '' && environmentShort == 'prod'
}

node("master") {
    checkout scm

    checkInputParameters(PROVIDED_VERSION, PROVIDED_ENV, PROVIDED_DC, PROVIDED_TENANT)

    configFile = readYaml file: "distribution/jenkins/deployment/configuration.yaml"

    final String tenant = PROVIDED_TENANT
    final String environmentShort = PROVIDED_ENV
    String versionToDeploy = PROVIDED_VERSION.trim()
    String dc = PROVIDED_DC
    final boolean force = PROVIDED_FORCE == 'true'

    if (useLpVersionForProd(versionToDeploy, environmentShort)) {
        // If the version is empty, deploy the version that's live on lp to prod
        versionToDeploy = commonFunctions.getCurrentlyDeployedVersion(tenant, 'ams1', 'lp')
    }

    if (environmentShort == "prod") {
        switch (dc) {
            case "active":
                dc = commonFunctions.getActiveDC(tenant, "prod")
                break
            case "passive":
                dc = commonFunctions.getPassiveDcProd(tenant)
                break
        }
    }

    currentBuild.description = "$PROVIDED_TENANT/$dc/$versionToDeploy"

    Integer nrOfInstances = environmentShort == 'lp' ? configFile.instances.lp : configFile.instances.prod[tenant] as Integer

    // enable urlprefixes for this tenant, which means API traffic in production will go to the Nomad nodes
    final boolean live = configFile.tenants.live.contains(tenant)

    stage("Deploying") {
        node("$environmentShort && $dc") {
            boolean skip = false

            if (force) {
                echo "Force deployment, not checking existing version. Note that deploy.py or levant may still not upgrade for same version."
            } else {
                try {
                    String currentlyDeployedVersion = commonFunctions.getCurrentlyDeployedVersion(tenant, dc, environmentShort)
                    echo "currentlyDeployedVersion == newVersion : $currentlyDeployedVersion == $versionToDeploy"
                    if (currentlyDeployedVersion == versionToDeploy) {
                        echo "Current Comaas $tenant version $currentlyDeployedVersion is up to date, nothing to update (desired version: $versionToDeploy)"
                        currentBuild.result = 'SUCCESS'
                        skip = true
                        return
                    }
                } catch (ex) {
                    deploymentFailed(tenant, versionToDeploy, dc, environmentShort, ex)
                } finally {
                    if (skip) {
                        cleanWs notFailBuild: true
                    }
                }
            }

            if (!skip) {
                try {
                    echo "About to deploy Comaas version $versionToDeploy to $environmentShort in $dc for $tenant"
                    notifyAboutPendingUpgrade(tenant, versionToDeploy, dc, environmentShort)

                    if (!commonFunctions.isVersionPresentInSwift(tenant, versionToDeploy)) {
                        error("Version $versionToDeploy for tenant $tenant was not found in Swift")
                    }

                    final String artifact = downloadVersionFromSwift(tenant, versionToDeploy)
                    loadPropsIntoConsul(tenant, versionToDeploy, environmentShort)
                    deployToEnv(tenant, artifact, environmentShort, versionToDeploy, dc, nrOfInstances, live)

                    final String graphitePayload = commonFunctions.createGraphitePayload('succeeded', commonFunctions.getAlias(tenant), "$versionToDeploy deployed")
                    sendGraphiteMetric(dc, environmentShort, graphitePayload)

                    final String activeDcSlack = activeDcSlackString(tenant, dc, environmentShort)
                    final String slackMessage = "Comaas version `$versionToDeploy` for `$tenant` successfully deployed to " +
                            "`$environmentShort` in `$dc` ${activeDcSlack} with ${nrOfInstances} API nodes"
                    sendToSlack('#00FF00', tenant, slackMessage, environmentShort)
                } catch (ex) {
                    deploymentFailed(tenant, versionToDeploy, dc, environmentShort, ex)
                } finally {
                    cleanWs notFailBuild: true
                }
            }
            if (env."SKIP_$tenant" != 'true') {
                try {
                    echo "Running smoke tests for $PROVIDED_TENANT against $PROVIDED_DC $PROVIDED_ENV"
                    build job: 'smoke-tests', parameters: [
                            string(name: 'PROVIDED_TENANT', value: "$PROVIDED_TENANT"),
                            string(name: 'PROVIDED_ENV', value: "$PROVIDED_ENV"),
                            string(name: 'PROVIDED_DC', value: "$PROVIDED_DC")
                    ], wait: false
                } finally {
                    cleanWs notFailBuild: true
                }
            }
        }
    }

    if (currentBuild.result == 'FAILURE') {
        currentBuild.result = 'UNSTABLE'
    }
}
